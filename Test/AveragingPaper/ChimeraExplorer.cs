using EngineLayer;
using MassSpectrometry;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Chemistry;
using Easy.Common.Extensions;
using Easy.Common.Interfaces;
using MzLibUtil;
using NUnit.Framework;
using Readers;

namespace Test.AveragingPaper
{

    [TestFixture]
    public class RunChimeraExplorer
    {
        [Test]
        public static void RunSingle()
        {
            var path = @"D:\Projects\SpectralAveraging\PaperTestOutputs\Searches\Refined\Sigma5AllBellsAndWhistles";
           // var path = @"D:\Projects\Top Down MetaMorpheus\ChimeraValidation\FullLCMS\BovineEquineCaliGPTMDCommonAndOxoModernAcceptAll";
            ChimeraExplorer.DoItOnThisDirectory(path);
        }
    }


    public static class ChimeraExplorer
    {
        public static void DoItOnAllDirectories(string directoryPath)
        {
            foreach (var dir in Directory.GetDirectories(directoryPath))
            {
                DoItOnThisDirectory(dir);
            }
        }

        public static void DoItOnThisDirectory(string directoryPath) // IsolationRange currently set to 1000 -> 2000
        {
            // find directory of last search and pull out the data file paths from the manuscript prose
            var finalSearchDirectory = Directory.GetDirectories(directoryPath).Last(p => p.Contains("Search"));
            var prosePath = Path.Combine(finalSearchDirectory, "AutoGeneratedManuscriptProse.txt");

            var prose = File.ReadAllLines(prosePath);
            var startIndex = Array.IndexOf(prose, "Spectra files: ") + 1;
            var endIndex = Array.IndexOf(prose, "Databases:");
            Dictionary<string, MsDataFile> dataFiles = new(endIndex - startIndex);
            for (int i = startIndex; i < endIndex; i++)
            {
                string withoutExtension = Path.GetFileNameWithoutExtension(prose[i].Trim());

                //TODO: remove this
                if (!withoutExtension.Contains("fract7"))
                    continue;

                MsDataFile file = MsDataFileReader.GetDataFile(prose[i].Trim());
                dataFiles.Add(withoutExtension, file);
            }

            // load in all psms and construct chimera groups
            var psms = GetAllPsmsWithinRange(finalSearchDirectory, 600, 900);
            //TODO: Remove where
            var chimeraCollections = ConstructChimeraCollections(psms.Where(p => p.FileNameWithoutExtension.Contains("fract7")).ToList(), dataFiles).ToList();

            // use chimera groups to construct IdSeries
            var idSeries = ConstructIDSeriesFromChimeraCollections(chimeraCollections).ToList();
            idSeries = IdSeries.SanitizeIdSeries(idSeries);


        }

        // ChimeraCollections are constructed with all ID's from the same precursor and ms2 scan at 1% FDR
        //      Sanitize removed chimeric ID's that do not share the same charge state as the base peak ID
        // ID Series are constructed by all ChimeraCollections from the Protein by acession and dataset
        //      Sanitize removes ID series with less than 3 charge states adn constructs MS1Collections
        // Ms1Collections are PSM's (1% FDR) that share the same precursor and ms1 scan after the above sanitization steps

        /// <summary>
        /// Returns all Psms within a time range from a MM run directory
        /// </summary>
        /// <param name="directoryPath">Path of the specific search directory</param>
        /// <param name="minScan"></param>
        /// <param name="maxScan"></param>
        internal static IEnumerable<PsmFromTsv> GetAllPsmsWithinRange(string directoryPath, double minScan,
            double maxScan)
        {
            var files = Directory.GetFiles(directoryPath, "*AllPSMs.psmtsv");
            if (!files.Any())
                throw new ArgumentException("No Psm File Found");

            foreach (var file in files)
            {
                var path = Path.GetDirectoryName(file)!.Split('\\')[^2];
                var psms = PsmTsvReader.ReadTsv(file, out _)
                    .Where(p => p.QValue <= 0.01)
                    .ToList();
                foreach (var psm in psms.Where(
                             psm => psm.PrecursorScanNum >= minScan && psm.PrecursorScanNum <= maxScan))
                {
                    psm.Dataset = path;
                    yield return psm;
                }
            }
        }

        
        /// <summary>
        /// Groups Psms into ChimeraCollections by their Ms2ScanNumber, PrecursorScanNum, and DataFile
        /// Then determines which ID was the base peak based upon distance from ms1 isolation window
        /// </summary>
        /// <param name="psms"></param>
        /// <param name="dataFiles"></param>
        /// <returns></returns>
        internal static IEnumerable<ChimeraCollection> ConstructChimeraCollections(List<PsmFromTsv> psms,
            Dictionary<string, MsDataFile> dataFiles)
        {
            dataFiles.Values.ForEach(p => p.InitiateDynamicConnection());
            foreach (var chimericGroup in psms.GroupBy(p =>
                         (p.Ms2ScanNumber, p.PrecursorScanNum, p.FileNameWithoutExtension)))
            {
                var scan = dataFiles[chimericGroup.First().FileNameWithoutExtension]
                    .GetOneBasedScan(chimericGroup.First().Ms2ScanNumber);
                yield return new ChimeraCollection(chimericGroup.ToList(), scan);
            }
            dataFiles.Values.ForEach(p => p.CloseDynamicConnection());
        }

        internal static IEnumerable<IdSeries> ConstructIDSeriesFromChimeraCollections(
            List<ChimeraCollection> chimeraCollections)
        {
            var idSeries = chimeraCollections.GroupBy(p => (p.BasePeakIdentification.ProteinAccession, p.BasePeakIdentification.Dataset));

            foreach (var series in idSeries)
            {
                yield return new IdSeries(series.ToList());
            }
        }

    }


    /// <summary>
    /// Class Representing a group of chimeric Psms with the psm whose precursor mz is closest to the ms1 isolation window being the base peak ID
    /// </summary>
    internal class ChimeraCollection
    {
        public int Ms1ScanNum => BasePeakIdentification.PrecursorScanNum;
        public int Ms2ScanNum => BasePeakIdentification.Ms2ScanNumber;
        public string DataFile => BasePeakIdentification.FileNameWithoutExtension.Replace("-calib", "")
            .Replace("-averaged", "");

        public double DeltaMz { get; init; }
        public double ScanPrecursorMz { get; init; }

        public PsmFromTsv BasePeakIdentification { get; }
        public List<PsmFromTsv> ChimericPsms { get; }

        public ChimeraCollection(List<PsmFromTsv> chimericPsms, MsDataScan scan)
        {
            if (chimericPsms.Select(p => (p.Ms2ScanNumber, p.PrecursorScanNum, p.FileNameWithoutExtension))
                    .Distinct().Count() != 1)
                throw new ArgumentException("Psms are not chimeric");
            if (scan.MsnOrder != 2)
                throw new ArgumentException("Must be the ms2 scan");
            if (scan.OneBasedScanNumber != chimericPsms.First().Ms2ScanNumber)
                throw new ArgumentException("Ms2 scan number from psm does not match scan");
            if (scan.OneBasedPrecursorScanNumber != chimericPsms.First().PrecursorScanNum)
                throw new ArgumentException("Ms1 scan numbers do not match");

            chimericPsms.ForEach(psm => psm.DeltaMz = psm.PrecursorMz - scan.IsolationMz!.Value);
            BasePeakIdentification = chimericPsms.MinBy(psm => Math.Abs(psm.DeltaMz));
            chimericPsms.Remove(BasePeakIdentification);
            chimericPsms.ForEach(psm => psm.DeltaMass = BasePeakIdentification.PrecursorMass - psm.PrecursorMass );

            
            ChimericPsms = chimericPsms;
            DeltaMz = BasePeakIdentification.PrecursorMz - scan.IsolationMz!.Value;

            ScanPrecursorMz = scan.IsolationMz!.Value;
        }

        /// <summary>
        /// Remove all chimeric IDs that do not have the same charge state as the base peak ID
        /// </summary>
        public void Sanitize()
        {
            var baseCharge = BasePeakIdentification.PrecursorCharge;
            var idsToRemove = ChimericPsms.Where(p => p.PrecursorCharge != baseCharge).ToList();
            idsToRemove.ForEach(p => ChimericPsms.Remove(p));
        }

        public override string ToString()
        {
            return $"{BasePeakIdentification.ProteinAccession},{Ms1ScanNum},{Ms2ScanNum},{ScanPrecursorMz}";
        }

    }

    /// <summary>
    /// Class representing a series of IDs from the same precursor at different charge states
    /// </summary>
    internal class IdSeries
    {
        public string BaseSequence { get; }
        public string ProteinAccession { get; }
        public string DataSet { get; }
        public DoubleRange Ms1Range { get; }
        public Dictionary<int, List<ChimeraCollection>> IdsByCharge { get; private set; }
        public Dictionary<int, List<ChimeraCollection>> IdsByMs2Scan { get; private set; }
        public Dictionary<int, List<ChimeraCollection>> IdsByMs1Scan { get; private set; }
        public List<Ms1Collection> Ms1Collections { get; private set; }
        List<ChimeraCollection> AllIds { get; }

        public IdSeries(List<ChimeraCollection> collection)
        {
            if (collection.Select(p => p.BasePeakIdentification.ProteinAccession).Distinct().Count() != 1)
                throw new ArgumentException("ChimeraCollections are not from the same protein");
    

            BaseSequence = collection.First().BasePeakIdentification.BaseSeq;
            ProteinAccession = collection.First().BasePeakIdentification.ProteinAccession;
            DataSet = collection.First().BasePeakIdentification.Dataset;
            Ms1Range = new DoubleRange(collection.Min(p => p.Ms1ScanNum), collection.Max(p => p.Ms1ScanNum));
            AllIds = collection;
            IdsByCharge = collection.GroupBy(p => p.BasePeakIdentification.PrecursorCharge)
                .OrderBy(p => p.Key)
                .ToDictionary(p => p.Key, p => p.ToList());
            IdsByMs2Scan = collection.GroupBy(p => p.Ms2ScanNum)
                .OrderBy(p => p.Key)
                .ToDictionary(p => p.Key, p => p.ToList());
            IdsByMs1Scan = collection.GroupBy(p => p.Ms1ScanNum)
                .OrderBy(p => p.Key)
                .ToDictionary(p => p.Key, p => p.ToList());
        }

        /// <summary>
        /// Call the sanitize method for all chimera collections in this series and update the Id dictionaries
        /// </summary>
        public void SanitizeChimeraCollections()
        {
            foreach (var collection in AllIds)
            {
                collection.Sanitize();
            }

            IdsByCharge = AllIds.GroupBy(p => p.BasePeakIdentification.PrecursorCharge)
                .OrderBy(p => p.Key)
                .ToDictionary(p => p.Key, p => p.ToList());
            IdsByMs2Scan = AllIds.GroupBy(p => p.Ms2ScanNum)
                .OrderBy(p => p.Key)
                .ToDictionary(p => p.Key, p => p.ToList());
            IdsByMs1Scan = AllIds.GroupBy(p => p.Ms1ScanNum)
                .OrderBy(p => p.Key)
                .ToDictionary(p => p.Key, p => p.ToList());

            Ms1Collections = AllIds.GroupBy(p => p.Ms1ScanNum)
                .Select(p => new Ms1Collection(p.ToList()))
                .ToList();
        }

        public static List<IdSeries> SanitizeIdSeries(List<IdSeries> series)
        {
            var sanitizedSeries = new List<IdSeries>();
            foreach (var idSeries in series)
            {
                idSeries.SanitizeChimeraCollections();
                if (idSeries.IdsByCharge.Count > 2)
                    sanitizedSeries.Add(idSeries);
            }

            return sanitizedSeries;
        }
        
        public override string ToString() => $"{ProteinAccession},{Ms1Range},{IdsByCharge.Count}";
    }

    /// <summary>
    /// Class representing a series of IDs from the same precursor and MS1 scan at different charge states
    /// </summary>
    internal class Ms1Collection : IdSeries
    {
        public Ms1Collection(List<ChimeraCollection> collection) : base(collection)
        {
            if (collection.Select(p => (p.Ms1ScanNum, p.DataFile)).Distinct().Count() != 1)
                throw new ArgumentException("ChimeraCollections are not from the same ms1 scan");
        }
    }


}
