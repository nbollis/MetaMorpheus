using Chemistry;
using EngineLayer.Util;
using MassSpectrometry;
using MzLibUtil;
using Omics;
using Omics.Fragmentation;
using Omics.Modifications;
using Proteomics;
using Proteomics.ProteolyticDigestion;
using Readers.SpectralLibrary;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data.Entity.Core.Metadata.Edm;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace EngineLayer.ClassicSearch
{
    public class ClassicSearchEngine : MetaMorpheusEngine
    {
        private readonly SpectralLibrary SpectralLibrary;
        private readonly MassDiffAcceptor SearchMode;
        private readonly List<IBioPolymer> Proteins;
        private readonly List<Modification> FixedModifications;
        private readonly List<Modification> VariableModifications;
        private readonly List<SilacLabel> SilacLabels;
        private readonly (SilacLabel StartLabel, SilacLabel EndLabel)? TurnoverLabels;
        private readonly SpectralMatch[] SpectralMatches;
        private readonly Ms2ScanWithSpecificMass[] ArrayOfSortedMS2Scans;
        private readonly double[] MyScanPrecursorMasses;
        private readonly bool WriteSpectralLibrary;
        private readonly bool WriteDigestionCounts;
        private readonly ReaderWriterLockSlim[] Locks;

        public readonly ConcurrentDictionary<(string Accession, string BaseSequence), int> DigestionCountDictionary; // Used to track the amount of digestion products from each protein when the option is enabled.

        public ClassicSearchEngine(SpectralMatch[] globalPsms, Ms2ScanWithSpecificMass[] arrayOfSortedMS2Scans,
            List<Modification> variableModifications, List<Modification> fixedModifications, List<SilacLabel> silacLabels, SilacLabel startLabel, SilacLabel endLabel,
            List<IBioPolymer> proteinList, MassDiffAcceptor searchMode, CommonParameters commonParameters, List<(string FileName, CommonParameters Parameters)> fileSpecificParameters,
            SpectralLibrary spectralLibrary, List<string> nestedIds, bool writeSpectralLibrary, bool writeDigestionCounts = false)
            : base(commonParameters, fileSpecificParameters, nestedIds)
        {
            SpectralMatches = globalPsms;
            ArrayOfSortedMS2Scans = arrayOfSortedMS2Scans;
            MyScanPrecursorMasses = arrayOfSortedMS2Scans.Select(b => b.PrecursorMass).ToArray();
            VariableModifications = variableModifications;
            FixedModifications = fixedModifications;
            SilacLabels = silacLabels;
            if (startLabel != null || endLabel != null) //else it's null
            {
                TurnoverLabels = (startLabel, endLabel);
            }

            SearchMode = searchMode;
            SpectralLibrary = spectralLibrary;
            WriteSpectralLibrary = writeSpectralLibrary;
            WriteDigestionCounts = writeDigestionCounts;
            DigestionCountDictionary = new();

            // Create one lock for each PSM to ensure thread safety
            Locks = new ReaderWriterLockSlim[SpectralMatches.Length];
            for (int i = 0; i < Locks.Length; i++)
            {
                Locks[i] = new ReaderWriterLockSlim();
            }

            // if we're doing a spectral library search, we can skip the reverse protein decoys generated by metamorpheus.
            // we will generate reverse peptide decoys w/ in the code just below this (and calculate spectral angles for them later).
            // we have to generate the reverse peptides instead of the usual reverse proteins because we generate decoy spectral
            // library spectra from their corresponding paired target peptides
            Proteins = spectralLibrary == null ? proteinList : proteinList.Where(p => !p.IsDecoy).ToList();
        }

        // Override for constructing from Protein
        public ClassicSearchEngine(SpectralMatch[] globalPsms, Ms2ScanWithSpecificMass[] arrayOfSortedMS2Scans,
            List<Modification> variableModifications, List<Modification> fixedModifications, List<SilacLabel> silacLabels, SilacLabel startLabel, SilacLabel endLabel,
            List<Protein> proteinList, MassDiffAcceptor searchMode, CommonParameters commonParameters, List<(string FileName, CommonParameters Parameters)> fileSpecificParameters,
            SpectralLibrary spectralLibrary, List<string> nestedIds, bool writeSpectralLibrary)
            : this(globalPsms, arrayOfSortedMS2Scans, variableModifications, fixedModifications, silacLabels, startLabel, endLabel,
                proteinList.Cast<IBioPolymer>().ToList(), searchMode, commonParameters, fileSpecificParameters, spectralLibrary, nestedIds, writeSpectralLibrary)
        {
        }

        protected override MetaMorpheusEngineResults RunSpecific()
        {
           Status("Getting ms2 scans...");

            double proteinsSearched = 0;
            int oldPercentProgress = 0;
            
            Status("Performing classic search...");

            if (Proteins.Any())
            {
                int maxThreadsPerFile = CommonParameters.MaxThreadsToUsePerFile;
                var proteinPartioner = Partitioner.Create(0, Proteins.Count);
                
                Parallel.ForEach(
                    proteinPartioner,
                    new ParallelOptions { MaxDegreeOfParallelism = maxThreadsPerFile },
                    (range, loopState) =>
                {


                    List<Product> peptideTheorProducts = new(); 
                    HashSet<MatchedFragmentIon> matchedFragmentIons = new();
                    Tolerance productTolerance = CommonParameters.ProductMassTolerance;
                    for (int i = range.Item1; i < range.Item2; i++)
                    {
                        // Stop loop if canceled
                        if (GlobalVariables.StopLoops) { return; }

                        // digest each protein into peptides and search for each peptide in all spectra within precursor mass tolerance
                        foreach (var specificBioPolymer in Proteins[i].Digest(CommonParameters.DigestionParams, FixedModifications, VariableModifications, SilacLabels, TurnoverLabels))
                        {

                            peptideTheorProducts.Clear();
                            specificBioPolymer.Fragment(CommonParameters.DissociationType, CommonParameters.DigestionParams.FragmentationTerminus, peptideTheorProducts);

                            // score each scan that has an acceptable precursor mass
                            foreach (ScanWithIndexAndNotchInfo scan in GetAcceptableScans(specificBioPolymer.MonoisotopicMass, SearchMode))
                            {
                                matchedFragmentIons.Clear();
                                Ms2ScanWithSpecificMass theScan = ArrayOfSortedMS2Scans[scan.ScanIndex];
                                int precursorCharge = theScan.PrecursorCharge;

                                // Match Fragment Ions
                                foreach (var product in peptideTheorProducts)
                                {
                                    // unknown fragment mass; this only happens rarely for sequences with unknown amino acids
                                    if (double.IsNaN(product.NeutralMass))
                                    {
                                        continue;
                                    }

                                    // get the closest peak in the spectrum to the theoretical peak
                                    var closestExperimentalMass = theScan.GetClosestExperimentalIsotopicEnvelope(product.NeutralMass);

                                    // is the mass error acceptable?
                                    if (closestExperimentalMass != null
                                        && productTolerance.Within(closestExperimentalMass.MonoisotopicMass, product.NeutralMass)
                                        && Math.Abs(closestExperimentalMass.Charge) <= Math.Abs(precursorCharge))//TODO apply this filter before picking the envelope
                                    {
                                        matchedFragmentIons.Add(new MatchedFragmentIon(product, closestExperimentalMass.MonoisotopicMass.ToMz(closestExperimentalMass.Charge),
                                            closestExperimentalMass.Peaks.First().intensity, closestExperimentalMass.Charge));
                                    }
                                }

                                if (matchedFragmentIons.Count < CommonParameters.ScoreCutoff)
                                    continue;

                                // Score the peptide-spectrum match
                                double tic = theScan.TotalIonCurrent;
                                double score = 0;
                                foreach (var ion in matchedFragmentIons)
                                {
                                    if (ion.NeutralTheoreticalProduct.ProductType != ProductType.D)
                                    {
                                        score += 1 + ion.Intensity / tic;
                                    }
                                }

                                var matchedIons = matchedFragmentIons.ToList(); // materialize before passing to another thread
                                AddPeptideCandidateToPsm(scan, score, specificBioPolymer, matchedIons);
                            }
                        }

                        // report search progress (proteins searched so far out of total proteins in database)
                        proteinsSearched++;
                        var percentProgress = (int)((proteinsSearched / Proteins.Count) * 100);

                        if (percentProgress > oldPercentProgress)
                        {
                            oldPercentProgress = percentProgress;
                            ReportProgress(new ProgressEventArgs(percentProgress, "Performing classic search... ", NestedIds));
                        }
                    }
                });
            }

            foreach (SpectralMatch psm in SpectralMatches.Where(p => p != null))
            {
                psm.ResolveAllAmbiguities();
            }

            return new MetaMorpheusEngineResults(this);
        }

        private void DecoyScoreForSpectralLibrarySearch(ScanWithIndexAndNotchInfo scan, IBioPolymerWithSetMods reversedOnTheFlyDecoy, Dictionary<DissociationType, List<Product>> decoyFragmentsForEachDissociationType, DissociationType dissociationType)
        {
            // match decoy ions for decoy-on-the-fly
            var decoyTheoreticalFragments = decoyFragmentsForEachDissociationType[dissociationType];

            if (decoyTheoreticalFragments.Count == 0)
            {
                reversedOnTheFlyDecoy.Fragment(dissociationType, CommonParameters.DigestionParams.FragmentationTerminus, decoyTheoreticalFragments);
            }
            Ms2ScanWithSpecificMass theScan = ArrayOfSortedMS2Scans[scan.ScanIndex];
            var decoyMatchedIons = MatchFragmentIons(theScan, decoyTheoreticalFragments, CommonParameters,
                matchAllCharges: WriteSpectralLibrary);

            // calculate decoy's score
            var decoyScore = CalculatePeptideScore(theScan.TheScan, decoyMatchedIons, fragmentsCanHaveDifferentCharges: WriteSpectralLibrary);

            AddPeptideCandidateToPsm(scan, decoyScore, reversedOnTheFlyDecoy, decoyMatchedIons);
        }

        private void AddPeptideCandidateToPsm(ScanWithIndexAndNotchInfo scan, double thisScore, IBioPolymerWithSetMods peptide, List<MatchedFragmentIon> matchedIons)
        {
            int scanIndex = scan.ScanIndex;
            var lockObj = Locks[scanIndex];
            // this is thread-safe because even if the score improves from another thread writing to this PSM,
            // the lock combined with AddOrReplace method will ensure thread safety

            lockObj.EnterReadLock();
            try
            {
                var existingPsm = SpectralMatches[scanIndex];
                if (existingPsm != null)
                {
                    double scoreDiff = thisScore - existingPsm.RunnerUpScore;
                    if (scoreDiff <= -SpectralMatch.ToleranceForScoreDifferentiation)
                        return; // Early exit with just read lock
                }
            }
            finally
            {
                lockObj.ExitReadLock();
            }

            // Need to modify, get write lock
            lockObj.EnterWriteLock();
            try
            {
                var existingPsm = SpectralMatches[scanIndex];

                // Double-check after acquiring write lock
                if (existingPsm != null)
                {
                    double scoreDiff = thisScore - existingPsm.RunnerUpScore;
                    if (scoreDiff <= -SpectralMatch.ToleranceForScoreDifferentiation)
                        return;
                }

                // if the PSM is null, create a new one; otherwise, add or replace the peptide
                if (existingPsm == null)
                {
                    SpectralMatches[scanIndex] = GlobalVariables.AnalyteType == AnalyteType.Oligo
                        ? new OligoSpectralMatch(peptide, scan.Notch, thisScore, scanIndex,
                            ArrayOfSortedMS2Scans[scanIndex], CommonParameters, matchedIons)
                        : new PeptideSpectralMatch(peptide, scan.Notch, thisScore, scanIndex,
                            ArrayOfSortedMS2Scans[scanIndex], CommonParameters, matchedIons);
                }
                else
                {
                    existingPsm.AddOrReplace(peptide, thisScore, scan.Notch,
                        CommonParameters.ReportAllAmbiguity, matchedIons);
                }
            }
            finally
            {
                lockObj.ExitWriteLock();
            }
            
        }

        private IEnumerable<ScanWithIndexAndNotchInfo> GetAcceptableScans(double peptideMonoisotopicMass, MassDiffAcceptor searchMode)
        {
            foreach (AllowedIntervalWithNotch allowedIntervalWithNotch in searchMode.GetAllowedPrecursorMassIntervalsFromTheoreticalMass(peptideMonoisotopicMass))
            {
                int scanIndex = GetFirstScanWithMassOverOrEqual(allowedIntervalWithNotch.Minimum);
                if (scanIndex < ArrayOfSortedMS2Scans.Length)
                {
                    var scanMass = MyScanPrecursorMasses[scanIndex];
                    while (scanMass <= allowedIntervalWithNotch.Maximum)
                    {
                        yield return new ScanWithIndexAndNotchInfo(allowedIntervalWithNotch.Notch, scanIndex);
                        scanIndex++;
                        if (scanIndex == ArrayOfSortedMS2Scans.Length)
                        {
                            break;
                        }

                        scanMass = MyScanPrecursorMasses[scanIndex];
                    }
                }
            }
        }

        private int GetFirstScanWithMassOverOrEqual(double minimum)
        {
            int index = Array.BinarySearch(MyScanPrecursorMasses, minimum);
            if (index < 0)
            {
                index = ~index;
            }

            // index of the first element that is larger than value
            return index;
        }
    }
}